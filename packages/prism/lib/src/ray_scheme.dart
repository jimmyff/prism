import 'ray_base.dart';
import 'ray_rgb.dart';

/// A color scheme that provides harmonious color relationships based on a primary color.
///
/// Automatically generates:
/// - Contrast text color (onRay) for accessibility
/// - Dark and light surface variants
/// - Accessibility-compliant luminance calculations using W3C WCAG standards
///
/// The scheme uses perceptual luminance to determine appropriate contrast colors
/// and generates surface variants by intelligently mixing with black or white.
///
/// Example:
/// ```dart
/// final scheme = RayScheme.fromRay(RayRgb.fromHex('#2196F3'));
/// print(scheme.isDark); // false
/// print(scheme.onRay.toHex()); // '#000000' (black text on blue)
/// print(scheme.luminance); // 0.540 (computed luminance)
///
/// // Use surface variants for different themes
/// final darkSurface = scheme.surfaceDark; // Darker variant
/// final lightSurface = scheme.surfaceLight; // Lighter variant
/// ```
class RayScheme<T extends Ray> {
  /// Luminance threshold for dark vs light classification
  static const double _darkThreshold = 0.5;

  /// Target luminance for dark surface variants
  static const double _targetDarkLuminance = 0.1;

  /// Target luminance for light surface variants
  static const double _targetLightLuminance = 0.9;

  /// Tolerance for floating point comparison
  static const double _epsilon = 1e-6;

  /// The primary color this scheme is based on
  final T ray;

  /// The appropriate contrast color for text on the primary color
  ///
  /// This is either black or white, chosen for optimal readability
  /// based on the primary color's luminance.
  final T onRay;

  /// The computed luminance of the primary color (0.0 to 1.0)
  ///
  /// Uses W3C WCAG relative luminance calculation for perceptual accuracy.
  final double luminance;

  /// Whether this color scheme is considered dark
  ///
  /// Based on luminance < 0.5 threshold for perceptual darkness.
  final bool isDark;

  /// A darker surface variant of the primary color
  ///
  /// Generated by mixing with black or white to achieve target luminance of 0.1.
  final T surfaceDark;

  /// A lighter surface variant of the primary color
  ///
  /// Generated by mixing with black or white to achieve target luminance of 0.9.
  final T surfaceLight;

  /// Creates a color scheme with all properties explicitly specified.
  ///
  /// For most use cases, prefer [RayScheme.fromRay] which automatically
  /// computes all derived colors and properties.
  const RayScheme({
    required this.ray,
    required this.onRay,
    required this.luminance,
    required this.isDark,
    required this.surfaceDark,
    required this.surfaceLight,
  });

  /// Creates a complete color scheme from a primary color.
  ///
  /// Automatically computes:
  /// - Luminance using W3C WCAG standards
  /// - Appropriate contrast color (onRay)
  /// - Dark and light surface variants
  /// - Dark/light classification
  ///
  /// The surface variants are generated using an intelligent mixing algorithm
  /// that pulls colors toward target luminance values while preserving hue.
  ///
  /// Example:
  /// ```dart
  /// final blueScheme = RayScheme.fromRay(RayRgb.fromHex('#2196F3'));
  /// final redScheme = RayScheme.fromRay(RayRgb.fromHex('#F44336'));
  /// ```
  factory RayScheme.fromRay(T ray) {
    final luminance = ray.computeLuminance();
    final isDark = luminance < _darkThreshold;

    final blackRgb = RayRgb(red: 0, green: 0, blue: 0);
    final whiteRgb = RayRgb(red: 255, green: 255, blue: 255);
    
    // Convert black/white to the same color model as the input ray
    final T black;
    final T white;
    switch (ray.colorModel) {
      case ColorModel.rgb:
        black = blackRgb as T;
        white = whiteRgb as T;
        break;
      case ColorModel.hsl:
        black = blackRgb.toHsl() as T;
        white = whiteRgb.toHsl() as T;
        break;
      case ColorModel.oklab:
        black = blackRgb.toOklab() as T;
        white = whiteRgb.toOklab() as T;
        break;
    }

    // Generate dark surface variant
    final T surfaceDark;
    if (luminance > _targetDarkLuminance) {
      final t = _getLerpAmount(
          _targetDarkLuminance, luminance, 0.0); // Mix with black (lum 0.0)
      surfaceDark = ray.lerp(black, t) as T;
    } else {
      final t = _getLerpAmount(
          _targetDarkLuminance, luminance, 1.0); // Mix with white (lum 1.0)
      surfaceDark = ray.lerp(white, t) as T;
    }

    // Generate light surface variant
    final T surfaceLight;
    if (luminance < _targetLightLuminance) {
      final t = _getLerpAmount(
          _targetLightLuminance, luminance, 1.0); // Mix with white
      surfaceLight = ray.lerp(white, t) as T;
    } else {
      final t = _getLerpAmount(
          _targetLightLuminance, luminance, 0.0); // Mix with black
      surfaceLight = ray.lerp(black, t) as T;
    }

    return RayScheme(
      ray: ray,
      onRay: isDark ? white : black,
      luminance: luminance,
      isDark: isDark,
      surfaceDark: surfaceDark,
      surfaceLight: surfaceLight,
    );
  }

  /// Whether this color scheme is considered light
  ///
  /// Opposite of [isDark] for convenience.
  bool get isLight => !isDark;

  /// Returns the appropriate text color for this color scheme
  ///
  /// Alias for [onRay] for semantic clarity.
  T get textColor => onRay;

  /// Helper function to calculate the lerp amount needed to reach a target luminance
  ///
  /// Formula: t = (target - current) / (mix_color - current)
  /// Avoids division by zero when current and mix luminance are identical.
  static double _getLerpAmount(double target, double current, double mix) {
    if ((mix - current).abs() < _epsilon) return 0.0;
    return (target - current) / (mix - current);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is RayScheme &&
        other.ray == ray &&
        other.onRay == onRay &&
        other.luminance == luminance &&
        other.isDark == isDark &&
        other.surfaceDark == surfaceDark &&
        other.surfaceLight == surfaceLight;
  }

  @override
  int get hashCode => Object.hash(
        ray,
        onRay,
        luminance,
        isDark,
        surfaceDark,
        surfaceLight,
      );

  @override
  String toString() => 'RayScheme('
      'ray: ${ray.colorModel.name}(${ray.toString()}), '
      'luminance: ${luminance.toStringAsFixed(3)}, '
      'isDark: $isDark'
      ')';
}
